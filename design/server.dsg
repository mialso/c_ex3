		server design doc
	[server purpose]:
* to help fsm provide its state to connected clients and to receive state-change requests
	[functional requirements]:
* serve as many connections as many system resources available
* serve connections on a fair base, dont stuck at one
* one single-threaded process
	[usage]:
FSMserver <port>
	* if port is not in range 50000..55000 inform user and pick system provided one
	* if port is not specified, the server starts with a system provided one and informs user

	[data model]
connection:
	server_socket
	client_socket
		state:
		accepted 	// connection accepted, new fd created
		in_queue	// connection get_state_request received, wait to be served
		sr_primary	// connection state_response sending 
		cs_primary	// connection state_change_req waiting 
		cr_primary	// connection state_change response sending 
error
signal
	pipe			// well known self-pipe trick to handle signals non-blocking way with select
timer				// the timer sends signals to update connection TTL and remove old stuff

	[workflow]
init_environment		// get & validate input information from user
	usage_informer		// informs user in case of error args and port choosen
init_listener
init_pipe 	// signals included
start_timer

main loop:
	wait_all
	handle_signals
	accept_connections
	respond_accepted
	handle_primary[sr, cs, cr]

	[concepts]
* non-blocking IO
* timer to check old connections and remove them
* wrong messages force server to close the spamming socket
* self-pipe signals handling (just for curiousity)
